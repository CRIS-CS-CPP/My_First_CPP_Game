#include <windows.h>
#include <iostream>

// global variable
bool RUNNING = true;

void* BUFFER_MEMORY = nullptr;
int BUFFER_WIDTH;
int BUFFER_HEIGHT;

BITMAPINFO BUFFER_BITMAP_INFO;

LRESULT window_callback(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // zero value return code
    LRESULT result = 0;

    switch (uMsg) {
        case WM_CLOSE:
        case WM_DESTROY: {
            RUNNING = false;
        } break;

        case WM_SIZE: {
            RECT rect;
            GetClientRect(hwnd, &rect);
            BUFFER_WIDTH = rect.right - rect.left;
            BUFFER_HEIGHT = rect.bottom - rect.top;

            int buffer_size = BUFFER_WIDTH * BUFFER_HEIGHT * sizeof(unsigned int);

            // free existing buffer
            if (BUFFER_MEMORY)
                VirtualFree(BUFFER_MEMORY, 0, MEM_RELEASE);

            BUFFER_MEMORY = VirtualAlloc(0, buffer_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

            BUFFER_BITMAP_INFO.bmiHeader.biSize = sizeof(BUFFER_BITMAP_INFO.bmiHeader);
            BUFFER_BITMAP_INFO.bmiHeader.biWidth = BUFFER_WIDTH;
            BUFFER_BITMAP_INFO.bmiHeader.biHeight = BUFFER_HEIGHT;
            BUFFER_BITMAP_INFO.bmiHeader.biPlanes = 1;
            BUFFER_BITMAP_INFO.bmiHeader.biBitCount = 32;
            BUFFER_BITMAP_INFO.bmiHeader.biCompression = BI_RGB;
        } break;

        default: {
            /*
             * DefWindowProc Calls the default window procedure to provide default
             * processing for any window messages that an application does not process
             */
            result = DefWindowProc(hwnd, uMsg, wParam, lParam);
        }
    }

    return result;
}

INT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR lpCmdLine, INT nCmdShow)
{
    // Create Window Class
    // https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassa
    WNDCLASS window_class = {};  // initialize to an empty struct

    // use bitwise OR to combine bits from the horizontal and vertical redraw options
    // this sets both options
    window_class.style = CS_HREDRAW | CS_VREDRAW;

    // LPCWSTR is defined as `const wchar*` which uses 16 bits for Unicode Characters (like non-English characters)
    window_class.lpszClassName = L"Game Window Class";

    /*
     * The system passes input to a window procedure in the form of a message.
     * Messages are generated by both the system and applications. The system
     * generates a message at each input event—for example, when the user
     * types, moves the mouse, or clicks a control such as a scroll bar.
     * https://learn.microsoft.com/en-us/windows/win32/winmsg/about-messages-and-message-queues#system-defined-messages
     */
    window_class.lpfnWndProc = window_callback;

    // Register Class (tell the OS this class is ready to use)
    // pass in a pointer to the address of the WNDCLASS object
    RegisterClass(&window_class);

    /*
     * Create (Overlapped) Window
     * An overlapped window is a top - level window(non - child window) that has a title bar,
     * border, and client area; it is meant to serve as an application's main window. It can
     * also have a window menu, minimize and maximize buttons, and scroll bars.
     */
    HWND window = CreateWindow(
        window_class.lpszClassName,  // class name previously created in RegisterClass()
        L"My First Game!",  // title bar text
        WS_OVERLAPPEDWINDOW | WS_VISIBLE, // window style options
        CW_USEDEFAULT,  // x position (use defaults)
        CW_USEDEFAULT,  // y position (use defaults)
        1280,           // width in pixels
        720,            // height in pixels
        nullptr,        // pointer to parent window - we don't have one so use nullptr (same as NULL or 0)
        nullptr,        // pointer to module (none)
        hInstance,      // pointer to this application instance if it was already running
        nullptr         // pointer to object that is passed in to the Window message callback parameter LPARAM
    );

    HDC hdc = GetDC(window);

    while (RUNNING) {
        /*****   Input   *****/

        // Contains message information from a thread's message queue.
        MSG message;

        /*
         * PeekMessage() Dispatches incoming nonqueued messages,
         * checks the thread message queue for a posted message,
         * and retrieves the message (if any exist).
         *
         * In other words, in this loop, we are processing incoming messages from the OS
         */
        while (PeekMessage(&message, window, 0, 0, PM_REMOVE)) {
            /*
             * Translates virtual-key messages into character messages.
             * The character messages are posted to the calling thread's message queue,
             * to be read the next time the thread calls the GetMessage or PeekMessage function.
             *
             * https://learn.microsoft.com/en-us/windows/win32/inputdev/about-keyboard-input
             */
            TranslateMessage(&message);

            /*
             * Dispatches a message to a window procedure.
             * (so that our window_callback() function gets called)
             */
            DispatchMessage(&message);
        }

        /*****   Simulate   *****/
        unsigned int* pixel = (unsigned int*)BUFFER_MEMORY;
        for (int y = 0; y < BUFFER_HEIGHT; y++) {
            for (int x = 0; x < BUFFER_WIDTH; x++) {
                *pixel++ = 0xFF0000;
            }
        }
        /*****   Render   *****/
        StretchDIBits(hdc, 0, 0, BUFFER_WIDTH, BUFFER_HEIGHT, 0, 0, BUFFER_WIDTH, BUFFER_HEIGHT, BUFFER_MEMORY, &BUFFER_BITMAP_INFO, DIB_RGB_COLORS, SRCCOPY);
    }

    return 0;
}